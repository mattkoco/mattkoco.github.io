<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LB{CTF}</title>
  <style>
    :root{
      --bg:#000000;
      --card:#000000;
      --muted:#9aa4b2;
      --text:#e6e6e6;
      --accent:#00ff7f;           /* terminal green */
      --ring: rgba(0,255,127,.22);
      --ok:#00ff7f;
      --warn:#ffd400;
      --hard:#ff5555;
      --shadow:none;
      --radius:6px;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#111111;
        --card:#111111;
        --text:#f2f2f2;
        --muted:#a9b1ba;
        --accent:#00ff7f;
        --ring: rgba(0,255,127,.22);
        --shadow:none;
      }
    }
    *{ box-sizing:border-box }
    html,body{ height:100% }
    body{
      margin:0;
      font: 15px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(0,0,0,0.00) 0px,
          rgba(0,0,0,0.00) 2px,
          rgba(0,255,127,0.02) 3px,
          rgba(0,0,0,0.00) 4px
        ),
        var(--bg);
      color:var(--text);
      text-shadow: 0 0 0.01em rgba(255,255,255,0.35);
    }
    header{
      max-width:1100px; margin:24px auto 10px; padding:0 20px; display:flex; align-items:center; gap:16px; flex-wrap:wrap;
    }
    .brand{ display:flex; align-items:center; gap:12px; flex:1 1 auto }
    .logo{ display:none !important; } /* keep image hidden */

    h1{ margin:0; font-weight:700; letter-spacing:.3px; font-size: clamp(18px, 3vw, 26px) }
    h1::after{ content:"_"; margin-left:6px; color:var(--accent); animation: blink 1s steps(1,end) infinite; }
    @keyframes blink{ 50%{ opacity:0 } }
    .muted{ color:#9da3ab; font-size:.95rem }

    .controls{ display:flex; gap:10px; flex-wrap:wrap; align-items:center }
    .input, .select{
      appearance:none;
      background:var(--card);
      color:var(--text);
      padding:9px 11px;
      border-radius:0;
      border:1px solid #2d2d2d;
      outline:none;
      min-width: 180px;
      box-shadow:none;
    }
    .select{ min-width: 140px }
    .input::placeholder{ color:#7d8995 }
    .input:focus, .select:focus{
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--ring);
    }
    .pill{ display:inline-flex; align-items:center; gap:8px; padding:5px 9px; border-radius:0; font-size:.78rem; background:transparent; border:1px dashed #2d2d2d }

    #pointsBadge{
      border:1px solid #2d2d2d; padding:6px 10px; border-radius:0; font-size:.85rem; color:#cfcfcf;
    }

    main{ max-width:1100px; margin:10px auto 50px; padding:0 20px }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap:14px }

    .card{
      background: var(--card);
      border:1px solid #2d2d2d;
      border-radius: 0;
      padding:14px;
      position:relative; overflow:hidden; cursor:pointer;
      transition: transform .06s ease, border-color .06s ease;
    }
    .card:hover{ transform: translateY(-1px); border-color: var(--accent) }
    .card h3{ margin:4px 0 6px; font-size:1rem; color:#f0f0f0 }
    .card .meta{ display:flex; gap:8px; flex-wrap:wrap; margin:8px 0 2px }
    .badge{
      display:inline-flex; align-items:center; gap:6px; padding:3px 6px; border-radius:0; font-size:.76rem;
      background:transparent; border:1px solid #2d2d2d; color:#cfcfcf;
    }
    .diff-easy{ color:var(--ok); border-color: rgba(0,255,127,.35); }
    .diff-med{ color:var(--warn); border-color: rgba(255,212,0,.35); }
    .diff-hard{ color:var(--hard); border-color: rgba(255,85,85,.35); }
    .date{ font-size:.78rem; color:#7a7a7a }

    .empty{ text-align:center; padding:40px 12px; color:#9da3ab }

    dialog{
      width:min(720px, 92vw);
      border:1px solid #2d2d2d;
      padding:0; border-radius: 0; overflow:hidden;
      background: var(--card); color:var(--text);
      box-shadow: none;
    }
    dialog::backdrop{ backdrop-filter: blur(2px) brightness(.75) }
    .modal-head{ padding:16px 18px; border-bottom:1px solid #2d2d2d; display:flex; align-items:center; justify-content:space-between; gap:12px }
    .modal-title{ margin:0; font-size:1.05rem }
    .modal-body{ padding:16px 18px; white-space:pre-wrap; word-wrap:break-word }
    .modal-meta{ display:flex; gap:8px; flex-wrap:wrap; margin:6px 0 0 }
    .close{
      border:1px solid #2d2d2d; background:transparent; color:var(--text);
      padding:7px 10px; border-radius:0; cursor:pointer; font: inherit;
    }
    .close:hover{ border-color: var(--accent); color:var(--accent) }
    .close:disabled{
      opacity:.5; cursor:not-allowed; border-color:#2d2d2d !important; color:#8c8c8c !important;
    }

    footer{ max-width:1100px; margin:22px auto 60px; padding:0 20px; color:#9da3ab; font-size:.9rem }
    a{ color: var(--accent); text-decoration: none }
    a:hover{ text-decoration: underline }

    /* Subtle CRT glow on big headings/titles */
    .modal-title, h3 { text-shadow: 0 0 2px rgba(0,255,127,0.08); }

    /* Confetti canvas overlay (pointer-events: none) */
    .fx-confetti{
      position:fixed; inset:0; z-index:9999; pointer-events:none;
    }
  </style>
  <script>
    // lightweight string obfuscation for casual source-skimmers
    const _b64 = s => atob(s);
  </script>
</head>
<body>
  <header>
    <div class="brand">
      <img class="logo" src="lbctf_logo.png" alt="" width="40" height="40" decoding="async" />
      <div>
        <h1>LB{CTF}</h1>
        <div class="muted">Weekly CTF Challenges for LBCSI</div>
      </div>
    </div>
    <div class="controls">
      <span id="pointsBadge">Points: <strong id="pointsTotal">0</strong></span>
      <input id="search" class="input" placeholder="Search title or text…" />
      <select id="category" class="select">
        <option value="">All categories</option>
        <option>crypto</option>
        <option>forensics</option>
        <option>web</option>
        <option>pwn</option>
        <option>rev</option>
        <option>misc</option>
      </select>
      <select id="difficulty" class="select">
        <option value="">Any difficulty</option>
        <option value="easy">easy</option>
        <option value="medium">medium</option>
        <option value="hard">hard</option>
      </select>
    </div>
  </header>

  <main>
    <section id="grid" class="grid" aria-live="polite"></section>
    <div id="empty" class="empty" hidden>No challenges match your filters.</div>
  </main>

  <dialog id="modal">
    <div class="modal-head">
      <div>
        <h2 id="modalTitle" class="modal-title"></h2>
        <div class="modal-meta">
          <span id="modalCat" class="badge"></span>
          <span id="modalDiff" class="badge"></span>
          <span id="modalDate" class="badge date"></span>
        </div>
      </div>
      <button class="close" onclick="modal.close()">Close</button>
    </div>
    <div id="modalBody" class="modal-body"></div>
    <div id="verifyWrap" class="modal-body" style="border-top:1px solid rgba(255,255,255,.06); display:none">
      <form id="verifyForm" onsubmit="return false;" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center">
        <input id="flagInput" class="input" placeholder="Enter flag" style="flex:1 1 240px" autocomplete="off" />
        <button id="checkBtn" class="close" type="button">Check flag</button>
        <span id="verifyMsg" class="muted"></span>
      </form>
    </div>
  </dialog>

  <!-- Admin hasher (client-side SHA-256 generator) -->
  <dialog id="hashModal">
    <div class="modal-head">
      <h2 class="modal-title">Admin Hasher</h2>
      <button class="close" type="button" onclick="hashModal.close()">Close</button>
    </div>
    <div class="modal-body">
      <label for="hashInput" class="muted">Enter exact flag text to hash (no salt):</label>
      <input id="hashInput" class="input" placeholder="CTF{your-flag-here}" style="width:100%; margin-top:8px" />
      <div id="hashOut" style="margin-top:12px; word-break:break-all"></div>
      <button id="copyHash" class="close" type="button" style="margin-top:10px">Copy hash</button>
    </div>
  </dialog>

  <footer>
    <button id="openHasher" class="close" type="button" title="Opens a local SHA-256 generator for admins">Open hasher (admin)</button>
  </footer>

  <script>
    // 1) EDIT ME: your daily challenges live here
    let challenges = [];

    // 2) Minimal rendering + filtering + verification logic
    const els = {
      grid: document.getElementById('grid'),
      empty: document.getElementById('empty'),
      search: document.getElementById('search'),
      category: document.getElementById('category'),
      difficulty: document.getElementById('difficulty'),
      modal: document.getElementById('modal'),
      mTitle: document.getElementById('modalTitle'),
      mCat: document.getElementById('modalCat'),
      mDiff: document.getElementById('modalDiff'),
      mDate: document.getElementById('modalDate'),
      mBody: document.getElementById('modalBody'),
      pointsTotal: document.getElementById('pointsTotal'),
    };

    function difficultyBadgeClass(level){
      if(level === 'easy') return 'badge diff-easy';
      if(level === 'medium') return 'badge diff-med';
      return 'badge diff-hard';
    }

    function render(){
      const q = els.search.value.trim().toLowerCase();
      const cat = (els.category.value||'').toLowerCase();
      const diff = (els.difficulty.value||'').toLowerCase();

      const list = challenges.filter(c => {
        const hay = (c.title + ' ' + c.body + ' ' + c.category + ' ' + c.difficulty).toLowerCase();
        const okQ = !q || hay.includes(q);
        const okC = !cat || c.category.toLowerCase() === cat;
        const okD = !diff || c.difficulty.toLowerCase() === diff;
        return okQ && okC && okD;
      });

      els.grid.innerHTML = '';
      if(list.length === 0){ els.empty.hidden = false; return; }
      els.empty.hidden = true;

      list.forEach(c => {
        const card = document.createElement('article');
        card.className = 'card';
        card.setAttribute('tabindex','0');
        card.setAttribute('role','button');
        card.setAttribute('aria-label', `${c.title}, ${c.category}, ${c.difficulty}`);
        card.innerHTML = `
          <span class="date">${c.date ?? ''}</span>
          <h3>${escapeHTML(c.title)}</h3>
          <div class="meta">
            <span class="badge">${escapeHTML(c.category)}</span>
            <span class="${difficultyBadgeClass(c.difficulty)}">${escapeHTML(c.difficulty)}</span>
            ${c.points ? `<span class="badge">+${c.points} pts</span>` : ``}
          </div>
        `;
        card.addEventListener('click', () => openModal(c));
        card.addEventListener('keypress', (e) => { if(e.key==='Enter' || e.key===' '){ openModal(c); }});
        els.grid.appendChild(card);
      });
    }

    function openModal(c){
      els.mTitle.textContent = c.title;
      els.mCat.textContent = c.category;
      els.mCat.className = 'badge';
      els.mDiff.textContent = c.difficulty;
      els.mDiff.className = difficultyBadgeClass(c.difficulty);
      els.mDate.textContent = c.date || '';

      const linkLine = c.link ? `\n\nAttachment: ${c.link}` : '';
      els.mBody.textContent = (c.body || '') + linkLine;

      const verifyWrap = document.getElementById('verifyWrap');
      const input = document.getElementById('flagInput');
      const msg = document.getElementById('verifyMsg');
      const btn = document.getElementById('checkBtn');

      const hasFlag = !!c["flag-hash"]; 
      verifyWrap.style.display = hasFlag ? 'block' : 'none';

      // Determine solved state from persisted store
      c._solved = isSolved(c.id);

      // Reset UI each time modal opens
      msg.textContent = '';
      input.value = '';
      input.disabled = !!c._solved;
      btn.disabled = !!c._solved;

      if (c._solved) {
        msg.textContent = 'Already solved.';
        msg.style.color = 'var(--ok)';
      }

      if(hasFlag){
        btn.onclick = async () => {
          if (btn.disabled) return; // guard
          const ok = await checkFlag(input.value, c["flag-hash"]);
          msg.textContent = ok ? 'Correct!' : 'Incorrect';
          msg.style.color = ok ? 'var(--ok)' : 'var(--hard)';
          if (ok) {
            // mark solved + award points once
            c._solved = true;
            btn.disabled = true;
            input.disabled = true;
            const pts = Number(c.points || 0);
            awardPoints(c.id, pts);
            updatePointsUI();
            startConfetti({ duration: 3000 });
          }
        };
      }

      els.modal.showModal();
      if(c.id) location.hash = c.id;
    }

    function escapeHTML(s){
      return (s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#039;'}[m]));
    }

    // wire filters
    els.search.addEventListener('input', render);
    els.category.addEventListener('change', render);
    els.difficulty.addEventListener('change', render);

    // (leftover verify precompute stays inert unless used)
    (async function initVerify(){
      for(const c of challenges){
        if(c.verify && c.verify.computeFrom){
          const canon = canonicalize(c.verify.computeFrom, c.verify);
          const dig = await sha256Hex(canon);
          c.verify.hashes = [dig];
          delete c.verify.computeFrom;
        }
      }
    })();

    // wire up admin hasher
    const hashModal = document.getElementById('hashModal');
    const openHasher = document.getElementById('openHasher');
    const hashInput = document.getElementById('hashInput');
    const hashOut = document.getElementById('hashOut');
    const copyHash = document.getElementById('copyHash');

    if(openHasher){
      openHasher.addEventListener('click', () => {
        hashInput.value = '';
        hashOut.textContent = '';
        hashModal.showModal();
        setTimeout(()=> hashInput.focus(), 50);
      });
    }
    if(hashInput){
      const updateHash = async () => {
        const v = hashInput.value;
        if(!v){ hashOut.textContent = ''; return; }
        const hex = await sha256Hex(v);
        hashOut.textContent = `sha256: ${hex}`;
      };
      hashInput.addEventListener('input', updateHash);
      hashInput.addEventListener('change', updateHash);
    }
    if(copyHash){
      copyHash.addEventListener('click', async () => {
        const txt = hashOut.textContent.replace('sha256: ', '').trim();
        if(!txt) return;
        try{
          if(navigator.clipboard && window.isSecureContext){
            await navigator.clipboard.writeText(txt);
          }else{
            const ta = document.createElement('textarea');
            ta.value = txt; document.body.appendChild(ta); ta.select();
            try{ document.execCommand('copy'); } finally { document.body.removeChild(ta); }
          }
        }catch(_e){ /* ignore */ }
      });
    }

    // crypto helpers
    async function sha256Hex(msg){
      if (window.crypto && window.crypto.subtle) {
        const enc = new TextEncoder();
        const data = enc.encode(msg);
        const buf = await crypto.subtle.digest('SHA-256', data);
        const bytes = new Uint8Array(buf);
        let hex = '';
        for (let i = 0; i < bytes.length; i++) hex += bytes[i].toString(16).padStart(2,'0');
        return hex;
      } else {
        return sha256HexPolyfill(msg);
      }
    }

    // Minimal SHA-256 polyfill (UTF-8 aware)
    function sha256HexPolyfill(str){
      const bytes = (function(s){
        const utf8 = unescape(encodeURIComponent(s));
        const out = new Uint8Array(utf8.length);
        for (let i=0; i < utf8.length; i++) out[i] = utf8.charCodeAt(i);
        return out;
      })(str);
      let h0=0x6a09e667,h1=0xbb67ae85,h2=0x3c6ef372,h3=0xa54ff53a,h4=0x510e527f,h5=0x9b05688c,h6=0x1f83d9ab,h7=0x5be0cd19;
      const K=[0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
        0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
        0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
        0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
        0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
        0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
        0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
        0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2];
      const bitLen = bytes.length * 8;
      const withOne = new Uint8Array(bytes.length + 1); withOne.set(bytes); withOne[bytes.length] = 0x80;
      let zeroPadLen = (56 - (withOne.length % 64) + 64) % 64;
      const padded = new Uint8Array(withOne.length + zeroPadLen + 8); padded.set(withOne);
      for(let i=0;i<8;i++) padded[padded.length-1-i] = (bitLen >>> (i*8)) & 0xff;
      const w = new Uint32Array(64);
      for(let i=0;i<padded.length;i+=64){
        for(let t=0;t<16;t++){
          const j=i + t*4;
          w[t] = (padded[j]<<24) | (padded[j+1]<<16) | (padded[j+2]<<8) | (padded[j+3]);
        }
        for(let t=16;t<64;t++){
          const s0 = ror(w[t-15],7) ^ ror(w[t-15],18) ^ (w[t-15]>>>3);
          const s1 = ror(w[t-2],17) ^ ror(w[t-2],19) ^ (w[t-2]>>>10);
          w[t] = (w[t-16] + s0 + w[t-7] + s1) >>> 0;
        }
        let a=h0,b=h1,c=h2,d=h3,e=h4,f=h5,g=h6,h=h7;
        for(let t=0;t<64;t++){
          const S1 = ror(e,6) ^ ror(e,11) ^ ror(e,25);
          const ch = (e & f) ^ (~e & g);
          const temp1 = (h + S1 + ch + K[t] + w[t]) >>> 0;
          const S0 = ror(a,2) ^ ror(a,13) ^ ror(a,22);
          const maj = (a & b) ^ (a & c) ^ (b & c);
          const temp2 = (S0 + maj) >>> 0;
          h=g; g=f; f=e; e=(d + temp1) >>> 0; d=c; c=b; b=a; a=(temp1 + temp2) >>> 0;
        }
        h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;
        h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;
      }
      return [h0,h1,h2,h3,h4,h5,h6,h7].map(n => n.toString(16).padStart(8,'0')).join('');
      function ror(x,n){ return (x>>>n) | (x<<(32-n)); }
    }

    async function checkFlag(flag, hashHex){
      const digest = await sha256Hex(String(flag || '').trim());
      return digest.toLowerCase() === String(hashHex || '').trim().toLowerCase();
    }

    // optional: open by hash on load
    window.addEventListener('load', () => {
      const byId = challenges.find(c => '#' + (c.id||'') === location.hash);
      if(byId) openModal(byId);
      // initialize points UI from cookie
      loadStore(); updatePointsUI();
    });

    /* ===== Terminal Confetti (no deps) ===== */
    function startConfetti({ duration = 3000, particleCount = 180 } = {}){
      const c = document.createElement('canvas');
      c.className = 'fx-confetti';
      document.body.appendChild(c);
      const ctx = c.getContext('2d');

      const DPR = Math.min(window.devicePixelRatio || 1, 2);
      function size(){ c.width = innerWidth * DPR; c.height = innerHeight * DPR; }
      size(); window.addEventListener('resize', size, { once:true });

      const colors = ['#00ff7f','#d7ff00','#00ffd5','#ffffff'];
      const parts = [];
      for(let i=0;i<particleCount;i++){
        const w = 6 + Math.random()*10;
        const h = 2 + Math.random()*4;
        const x = Math.random()*c.width;
        const y = -Math.random()*c.height*0.25;
        const vx = (Math.random()-0.5)*0.6 * DPR;
        const vy = (1.2 + Math.random()*1.2) * DPR;
        const rot = Math.random()*Math.PI*2;
        const vr = (Math.random()-0.5)*0.2;
        const col = colors[(Math.random()*colors.length)|0];
        parts.push({x,y,vx,vy,w,h,rot,vr,col,life:1});
      }

      let start = performance.now();
      let last = start;
      const fadeStart = start + duration * 0.65;

      function tick(t){
        const dt = (t - last) / 16.6667; last = t;
        ctx.clearRect(0,0,c.width,c.height);

        for(const p of parts){
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.rot += p.vr * dt;
          p.vy += 0.03 * DPR * dt;
          p.vx *= 0.995;

          if (t > fadeStart) {
            const k = 1 - (t - fadeStart) / (duration - (fadeStart - start));
            p.life = Math.max(0, Math.min(1, k));
          }

          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = p.col;
          ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
          ctx.restore();
        }

        if (t - start < duration) {
          requestAnimationFrame(tick);
        } else {
          document.body.removeChild(c);
        }
      }
      requestAnimationFrame(ts => { last = ts; tick(ts); });
    }
    /* ===== /Terminal Confetti ===== */

    /* ===== Cookie-backed Points Store (lightly signed) ===== */
    const STORE_COOKIE = 'lbctf_points';
    // “secret” is split/obfuscated to avoid casual grepping; still public in client code.
    const SECRET = (function(){
      const chunks = ['bEJ7','Q1RGfS0t','c2VjcmV0LXNlZWQ=']; // "lB{CTF}--secret-seed" b64-ish pieces
      return atob(chunks.join('')).slice(1, -1); // shave braces to be less obvious
    })();

    let store = { v:1, points:0, solved:{} };

    function setCookie(name, value, days=180){
      const d = new Date();
      d.setTime(d.getTime() + days*24*60*60*1000);
      const expires = "expires="+ d.toUTCString();
      // SameSite=Strict; Secure only works under https (ignored on file://)
      document.cookie = `${name}=${encodeURIComponent(value)}; ${expires}; path=/; SameSite=Strict`;
    }
    function getCookie(name){
      const cname = name + "=";
      const arr = document.cookie ? document.cookie.split(';') : [];
      for(let c of arr){
        c = c.trim();
        if(c.indexOf(cname) === 0) return decodeURIComponent(c.substring(cname.length));
      }
      return "";
    }

    async function signPayload(payload){
      // HMAC-like: sha256( SECRET + '|' + payload )
      return await sha256Hex(SECRET + '|' + payload);
    }

    function loadStore(){
      try{
        const raw = getCookie(STORE_COOKIE);
        if(!raw) return;
        const obj = JSON.parse(raw);
        if(!obj || !obj.payload || !obj.sig) return;

        const payload = obj.payload;
        // verify signature sync wrapper (uses async sha but quickly)
        // Since top-level can't await, use thenable trick:
        let ok = false;
        // NOTE: For simplicity, we block on a fake sync verify by using a small hack:
        // We *temporarily* set a flag, then the caller (window.load) won't care if it re-renders before verify.
        // But to keep things consistent here, we'll do a synchronous-ish fetch using a sync XHR-like pattern is not allowed.
        // Instead, we’ll use a simpler approach: compute a quick polyfill SHA which is already sync.
        const sigCheck = sha256HexPolyfill(SECRET + '|' + payload);
        if (sigCheck && sigCheck === obj.sig){
          const parsed = JSON.parse(payload);
          if (parsed && typeof parsed.points === 'number' && parsed.solved && typeof parsed.solved === 'object'){
            store = parsed;
            ok = true;
          }
        }
        if(!ok){
          // signature failed -> reset to safe defaults
          store = { v:1, points:0, solved:{} };
          persistStore();
        }
      }catch(_e){
        store = { v:1, points:0, solved:{} };
        persistStore();
      }
    }

    async function persistStore(){
      const payload = JSON.stringify(store);
      const sig = await signPayload(payload);
      const wrapped = JSON.stringify({ payload, sig });
      setCookie(STORE_COOKIE, wrapped);
    }

    function isSolved(id){
      return !!store.solved[id];
    }

    function awardPoints(id, pts){
      if (!store.solved[id]) {
        store.solved[id] = { t: Date.now(), pts: Number(pts||0) };
        store.points = Number(store.points || 0) + Number(pts||0);
        // Fire and forget (don’t block UI)
        persistStore();
      }
    }

    function updatePointsUI(){
      els.pointsTotal.textContent = Number(store.points || 0);
    }
    /* ===== /Cookie-backed Points Store ===== */

    // --- CHALLENGES (edit below this line) ---
    challenges = [
      {
        id: "sanity-check",
        points: 50,
        title: "Sanity Check",
        category: "misc",
        difficulty: "easy",
        date: "2025-10-09",
        body: "Warmup: decode this base64 string and follow the usual flag format. Base64: bGJjdGZ7Y2hlY2t5b3VyYnJhaW59",
        "flag-hash": "019175aae9a148e2caba4329ec19318b3c49dae8b6b68436f291ccf6d9c04366"
      },
      {
        id: "wall-e",
        points: 75,
        title:"wall-e",
        category: "web",
        difficulty: "easy",
        date: "2025-10-09",
        body: "I hid a flag somewhere on this site where the web crawlers will NEVER find it... can you find it?",
        "flag-hash": "ce28a0fce260874f93caadd33ce3d9f7d1f75836cb8823e3f851014ea6d3354f"
      },
      {
        id: "rsa-1",
        points: 100,
        title:"Really super awesome encryption",
        category:"crypto",
        difficulty: "easy",
        date: "2025-10-13",
        body: "Whats an RSA??? Ciphertext: https://tinyurl.com/bddwwc7",
        "flag-hash": "c0a271b3a7f1100ebfeee321350376a8143cf6c5dc3bd073be2aa3e7ed8ecb39"
      }
    ];

    // Render grid now that challenges exist
    render();

  </script>
</body>
</html>
